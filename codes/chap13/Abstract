세상의 다양한 문제는 그래프로 공식화하면 전체 모습을 파악하기 좋아짐.
우선 그래프 탐색법부터 설명. --> 다양한 그래프 알고리즘의 기초가 됨.

1. 그래프 탐색을 배우는 의의
다양한 대상을 넓은 시야로 탐색해서 파악 가능함.

2. 깊이 우선 탐색과 너비 우선 탐색 (13_1)
그래프에 존재하는 어떤 꼭짓점에서 출발해 그 꼭짓점에 연결된 변을 따라가면서 각 꼭짓점을 순서대로 탐색하는 방법.
대표적인 그래프 탐색 방법에는 깊이 우선 탐색(depth-first search, DFS)와 너비 우선 탐색(breadth-first search, BFS)이 있음.
DFS - 무조건 전진 - LIFO - Stack
BFS - 전체를 훑고 난 후 진행하는 탐색 - FIFO - Queue

*그래프 탐색에서 사용하는 데이터
1. Seen : vector<bool> - 해당 vertex를 방문했는지 조사
2. Todo : stack<int> 또는 queue<int> - 방문 예정인 vertex를 저장함

*vertex의 상태는 3개로 구성됨 --> 아직 미발견인 상태 / 방문 예정이지만 아직 방문하지 않음 / 이미 방문함

3. 재귀 함수를 사용하는 깊이 우선 탐색 (13_2)
깊이 우선 탐색은 재귀 함수와 궁합이 좋아서 재귀 함수를 사용하면 훨씬 간결한 구현이 가능함.
또한 재귀 함수를 사용하면 전위 순회, 후위 순회라는 중요한 개념도 명확해짐.

4. 전위 순회와 후위 순회
... 13.9절의 위상 정렬, 13.10절에서 다루는 트리 동적 계획법
13_1에서 꼭짓점 v를 todo에서 꺼내는 타이밍 = 13_2에서 재귀 함수 dfs(G,v)가 호출되는 타이밍
설명 편의를 위해 대상이 되는 그래프 = 루트 트리이고, 루트를 시작점으로 깊이 우선 탐색을 한다고 가정함.
전위 순회(root-left-right) : v의 후손이 되는 꼭짓점은 v보다 나중에 등장
후위 순회(left-right-root) : v의 후손이 되는 꼭짓점은 v보다 먼저 등장

5. 최단 경로 알고리즘으로 너비 우선 탐색(BFS) (13_3)
너비 우선 탐색이 탐색 시작점인 꼭짓점 s에서 각 꼭짓점을 향하는 최단 경로를 구하는 알고리즘이 된다는 걸 살펴보겠음.
13_3 : BFS + 시작점에서 각 꼭짓점을 향한 최단 경로 길이도 구하도록 수정한 코드
너비 우선 탐색은 dist 값이 작아지는 순서로 탐색하는 알고리즘임 시작문 s에서 출발해 dist가 1인 항목을 모두 탐색, 탐색이 끝나면
dist값이 2인 항목에 대해 모두 탐색, 그 다음에는 dist값이 3인 것 확인 ... 반복(모든 vertex를 방문할 때까지)

6. 깊이 우선 탐색과 너비 우선 탐색의 복잡도
보통은 그래프 G = (V, E)에 대한 알고리즘 복잡도를 조사한다면 보통은 꼭짓점 개수 |V|, 변의 개수 |E|가 입력 크기가 된다.
밀집 그래프(dense graph) --> |E| = theta(|V|^2) (상한, 하한이 모두 만족)
희소 그래프(sparse graph) --> |E| = O(|V|)
이렇듯 다루는 그래프의 성질에 따라 |V|와 |E|의 균형이 다르므로 그래프 알고리즘 복잡도를 나타낼 때는 |V|와 |E| 두 가지가 입력 크기가 됨.

DFS, BFS 모두 다음이 성립
1. 각 꼭짓점 v에 주목하면 최대 한 번 탐색(같은 꼭짓점을 두 번 탐색하지 않음)
2. 각 변 e = (u, v)에 주목하면 최대 한 번 탐색(변 e의 시작점 u를 두 번 탐색하지 않음)
따라서 DFS, BFS의 복잡도는 둘 다 O(|V| + |E|)이고, 이는 그래프를 입력받는 것과 동일한 복잡도로 그래프 탐색도 실시할 수 있음을 의미한다.

7. 그래프 탐색 예: s-t path 구하기 (13_4)
대다수 문제는 DFS, BFS 중 어느 탐색법을 사용해도 해결 가능하지만, 여기서는 DFS로 푸는 해법을 중심으로 설명함.
유향 그래프 G = (V, E)와 그래프 G 위의 두 꼭짓점 s, t가 주어졌을 때 s-t path가 존재하는지 여부를 판정하는 문제(s에서 출발해 t에 도달 가능한지 판별하는 문제)
--> DFS, BFS 중 어느 쪽이든 꼭짓점 s를 시작점으로 하는 그래프 탐색을 하고, 그 과정에서 꼭짓점 t를 방문했는지 여부를 조사하면 문제를 해결 가능함.

8. 그래프 탐색 예: 이분 그래프(bipartite graph) 판정 (13_5) - DFS
이분 그래프 : 흰색 꼭짓점끼리 인접하지 않고 검은색 꼭짓점끼리도 인점하지 않는 조건을 만족하도록 각 꼭짓점을 흰색 또는 검은색으로 나눠서 칠할 수 있는 그래프를 말함.
그래프를 좌우 카테고리로 분할해서 같은 카테고리에 속하는 꼭짓점끼리는 변이 없는 상태로 만들 수 있다는 것.

주어진 그래프 G가 이분 그래프인지 여부를 판정하는 방법 :
G가 연결 : 임의의 두 꼭짓점 s, t에 대해 s-t pathr가 존재하는 경우
G가 연결이 아닌 경우라면, 모든 연결 요소가 이분 그래프인지 여부를 판정하면 되므로 G가 연결인 경우만 생각하면 됨.
우선 G의 한 꼭짓점을 고른 후 흰색으로 칠하고 --> 이 꼭짓점에 인접한 꼭짓점들을 모두 검은색으로 칠함.
검은색에 인접한 꼭짓점들은 모두 흰색으로 칠함.
이 과정에서 양 꼭짓점 색이 같은 변이 등장하면 이분 그래프가 아닌 것을 확인 가능함. (그런 일이 없는 경우 이분 그래프임이 확정됨)

9. 그래프 탐색 예: 위상 정렬(topological sort) (13_6)
유항 그래프에 대해 각 꼭짓점이 변 방향을 따르도록 순서를 재정렬하는 것.
응용 : make같은 빌드 시스템에서 의존 관계를 해결하는 처리가 있음.
모든 유향 그래프가 위상 정렬이 가능한 것은 아니므로 주의.
위상 정렬을 하려면 주어진 그래프 G에 유향 사이클이 존재하지 않아야 함. --> DAG(directed acyclic graph)라 함.
또한, 위상 정렬 순서는 하나가 아니라 여러 개 존재하는 게 보통임.

DFS에서 재귀 함수를 빠져나가는 순서로 꼭짓점을 나열하고 그것을 거꾸로 뒤집으면 위상 정렬 순서를 얻을 수 있다.

10. 그래프 탐색 예: 트리 동적 계획법 (13_7, 13_8, 
트리 관련 문제를 풀 때 루트 존재 여부를 딱히 고려하지 않는 경우도 많음.
루트 없는 트리에 대해서도 편의를 위해 어떤 꼭짓점을 루트라고 정해서 루트 트리처럼 다루면 전체 모양을 파악하기 좋음.(18.2절 - 가중치 최대 안정 집합 문제 등.)
트리에 루트를 지정하면, 어떤 꼭짓점이 부모이고 어떤 꼭짓점이 자손인지를 나타내는 계통수(phylogenetic tree) 구조가 만들어짐.
각 꼭짓점의 후위 순회에서 자식 꼭짓점 정보를 합치고 싶을 때가 많으므로 깊이 우선 탐색을 사용하는 게 좋음.

*각 꼭짓점 v에 대해 구해야 할 것 
1. 꼭짓점 v의 깊이 --> 전위 순회 때 구함
2. 꼭짓점 v를 루트로 하는 부분 트리 크기(부분 트리에 포함된 꼭짓점 개수) --> 동적 계획법이 사용됨(후위 순회 때 구함)

전위 순회를 의식한 처리는 부모 꼭짓점 정보를 자식 꼭짓점에 전하는 데 적합하고,
후위 순회를 의식한 처리는 자식 꼭짓점 정보를 모아서 부모 꼭짓점 정보를 갱신하는 데 적합함.

11. 정리
14장(가중 그래프)에서 설명할 최단 경로 알고리즘은 BFS를 일반화한 것으로 볼 수 있고,
15장(Minimum Spanning Tree + Kruskal alg(Greedy))
16장에서 설명할 네트워크 흐름은 서브 루틴으로 그래프 탐색 기법이 활약함.

13장에서는  unweighted graph에 대해 BFS로 최단 경로를 구해 봄.
이 장에서는 좀 더 일반적인 weighted graph에 대해서 최단 경로 문제를 푸는 방법을 보겠음.
그래프의 최단 경로에 관한 각종 알고리즘은 5장의 동적 계획법의 직접적인 응용임
게다가 그래프의 각 변의 가중치의 음수가 아닌 경우에 적용가능한 다익스트라 알고리즘은 7장의 greedy method에 기반한 알고리즘임.

1. 최단 경로 문제란?
그래프에서 길이가 최소인 경로(walk)를 구하는 문제.
그래프 각 edge의 가중치를 l(e)라고 표기함.
그리고 경로 W, 닫힌 경로 C, 길 P의 길이를 각각 l(W), l(C), l(P)라 표기하겠음.
경로(walk) / 닫힌 경로(cycle) / 길(path)

10.1.3절)
s-t walk : 두 vertex s, t에 대해 s에서 t를 향해 인접하는 vertex들을 따라가다 도달할 수 있다면 그 경 s-t walk, s-t path라 함.
cycle : walk 중에서 시작점과 종점이 같은 것(=closed path)
path : walk 중에서 특히 같은 꼭짓점을 두 번 이상 통과하지 않는 것

1)가중치 유향 그래프(weighted directed graph)
unweighted graph : 각 edge의 weight가 1인 그래프
undirected graph : e=(u, v)에 대응하는 양방향의 변 (u, v), (v, u)가 존재하는 directed graph

weighted directed graph는 일반성이 높은 고찰 대상으로, 또한 서로 반대방향에 대해 다른 weight를 가질 수 있음.

2)단일 시작점 최단 경로 문제
한 꼭짓점 s가 주어지고, s에서 각각의 꼭짓점에 도달하는 최단 경로를 구하는 문제임.
각 꼭짓점을 향한 최단 경로를 겹쳐 보면 시작점(s)를 root로 하는 root tree가 되는 것을 볼 수 있음.

3)음의 변과 음의 닫힌 경로
음의 변 : 음의 가중치를 가진 edge
음의 닫힌 경로(negative cycle) : 길이가 음수인 닫힌 경로(cycle) --> 최단 경로 문제에서 주의 필요
negative cycle이 있는 경우 --> bellman-ford / 없는 경우 --> dijkstra

2. 최단 경로 문제 정리
DAG(Directed Acyclic Graph) : 유향 사이클이 없는 그래프 - 한 방향으로 이어지지만 순환은 하지 않는 그래프
DAG의 최단 경로 문제는 어떤 변에서부터 차례로 완화해야 하는지 명확하므로 각 꼭짓점을 향한 최당 경로가 차례차례 정해짐.(한 방향으로 진행하니까)

3. 완화 (14_1)
최단 경로 문제는 몇몇 꼭짓점과 그것을 묶은 몇 개의 끈으로 구성된 객체에 대해, 
특정 꼭짓점 s를 집어서 남은 꼭짓점을 팽팽하게 당겼을 때 각각의 꼭짓점이 s에서 얼마나 떨어져 있는지를 구하는 문제로 해석 가능함.

앞으로 검토할 최단 경로 알고리즘은 완화를 반복하여 각 노드를 조금씩 노드 s 방향으로 끌어 당기는 알고리즘.
어느 변에 대해 완화를 하더라도 노드 위치가 갱신되지 않는 상태가 되면 알고리즘 종료가 가능함.

4. DAG(Directed Acyclic Graph)의 최단 경로 문제 : 동적 계획법
-시작 꼭짓점 s에서 각 꼭짓점을 향한 최단 경로 길이를 동적계획법에 기반해 순서대로 구현했음. (5.2절)
*DAG의 완화 처리 순서 포인트
: 각 변 e = (u, v)에 대한 완화 처리를 실시할 때는 꼭짓점 u에 대한 d[u]가 실제 최단 경로 길이에 수렴한다.
DAG 전체를 위상 정렬하면 완화해야 할 변의 순서가 명확해짐. --> 순서대로 완화함으로써 각 꼭짓점에 도달하는 최단 경로를 구할 수 있음.
위상 정렬과 각 변의 완화 처리는 모두 O(|V|+|E|) 복잡도로 실행 가능.

5. 단일 시작점 최단 경로 문제 : Bellman-Ford algorithm. (14_2)
유향의(directed) cyclic(cycle이 있는) graph에 대해서도 최단 경로를 구할 수 있는 알고리즘 생각해 보기.
Bellman-Ford alg : 만약 시작점 s에서 도달 가능한 음의 닫힌 경로(cycle)가 존재하면 그 사실을 보고하고, 음의 cycle가 존재하지 않으면 각 꼭짓점 v를 향한 최단 경로를 구하는 알고리즘임.
+변의 가중치가 모두 음수가 아니라면 dijkstra algorithm이 유효함.

유향의 닫힌 경로 그래프는 유효한 변 완화 순서를 알지 못함. --> 값 갱신이 되지 않을 때까지 반복.
실은 시작점 s에서 도달 가능한 음의 닫힌 경로가 존재하지 않는 경우에 많아도 |V| - 1번 반복하면 d[v] 값이 실제 최단 경로 길이 d*[v]에 수렴하는 걸 확인 가능함.
각 변에 대한 완화가 O(|E|)이고 그걸 |V|회 반복하므로 bellman-ford algorithm의 복잡도는 O(|V||E|)임을 알 수 있음.

3) 정확성
시작점 s에서 도달 가능한 음의 닫힌 경로가 존재하지 않는 그래프는 많아도 |V| - 1번 반복하면 알고리즘이 수렴하고
시작점 s에서 도달 가능한 음의 닫힌 경로가 존재하는 경우는 |V|번째 반복할 때 반드시 갱신이 발생하는 걸 확인 가능함.

도달 가능한 음의 닫힌 경로가 없는 그래프에서 길이가 최소인 경로(walk)를 구하는 최단 경로 문제를, 길이가 최소인 길(path)을 구하는 최단 경로 문제로 바꿔 생각해도 된다.(path는 같은 꼭짓점을 두 번 통과하지 않음)
따라서 이 경우의 최단 경로 문제는 길만 대상으로 고려함. 즉 경로에 edge의 개수가 많아도 |V|-1 이하인 것만 생각하면 되고, 
이는 각 변을 완화하는 처리를 최대 |V|-1만 반복하면 시작점 s에서 모든 도달 가능한 모든 꼭짓점에 대해 최단 경로 길이를 구할 수 있음을 의미함.


6. 단일 시작점 최단 경로 문제 : Dijkstra algorithm. (14_3, 14_4)
모든 변의 가중치가 음수가 아니라는 걸 알고 있는 경우에 유용함

*자료구조에 따라 복잡도가 달라짐
단순 구현 : O(|V|^2)
힙을 사용하는 구현 : O(|E|log|V|)

밀집 그래프의 경우(|E| = theta(|V|^2) --> 단순 구현이 유리.
희소 그래프(|E| = O(|V|))의 경우 --> Heap을 사용하는 것이 유리함.
물론 둘 다 Bellman-Ford (O(|V||E|)) 보다는 개선되었음.

-일반 구현 (14_3)
다익스트라 알고리즘은 greedy method에 기반한 알고리즘임.
DAG인지 모르는 일반 그래프라면 적절한 변의 완화 순서를 알 수 없지만, 모든 변의 가중치가 음수가 아닌 경우, 최단 경로 추정 값 d[v]를 동적으로 갱신하는 과정에서 완화해야 할 꼭짓점 순서가 자동적으로 정해지는 구조가 됨.
다익스트라 알고리즘은 이미 최단 경로가 확정된 꼭짓점 집합 S를 관리함.
다익스트라 알고리즘은 이렇게 각 노드를 왼쪽부터 순서대로 팽팽하게 당기는 동작을 알고리즘으로 실현한 것.

-힙을 사용하는 경우 (14_4)
희소 그래프인 경우 --> O(|E|log|V|) = O(|V|log|V|)가 되지만
밀접 그래프인 경우 --> O(|E|log|V|) = O(|V|^2log|V|)가 되어서 일반 구현을 쓰는것이 더 좋음.
속도 향상이 가능한 부분 : 미사용 꼭짓점 v중 d[v]값이 최소인 꼭짓점을 찾는 부분 --> Min Heap을 쓰자. 기존의 선형 탐색에서 Heap을 사용(O(|V|) --> O(log|V|)
하지만 완화과정에서 복잡도가 상승함 (임의접근)(O(1) --> O(log|V|))(힙)
키 값 변경 후에 힙을 만족하도록 힙을 구성하는것 보다 하나의 vertex에대해 더 갱신된 값을 heap에 삽입하는 방법을 이용. --> 쓰레기 값을 포함하는 힙을 사용해도 복잡도에는 큰 영향이 없다.

코드 14_4가 코드 13_3(BFS)와 유사함. (queue -> priority_queue)
이건 다익스트라 알고리즘이 짧은 거리의 우선 탐색이라고 볼 수 있다는 의미임. 이러한 탐색을 최상 우선 탐색(best-first search)라고 부르기도 함.


7. 모든 쌍의 최단 경로 문제 : Floyd-Warshall algorithm (14_5)
(all pair shortest path problem)
복잡도 : O(|V|^3)
동적 계획법 : d[k][i][j] - 꼭짓점 0, 1, ... k-1만 중계 꼭짓점으로 통과해도 된다고 할 때 꼭짓점 i에서 꼭짓점 j를 향한 최단 경로 길이
초기 조건 : d[0][i][j] = 0 (i=j) / l(e) (e = (i,j)가 존재) / infinity (otherwise)
dp[k+1][i][j] = min(dp[k][i][j], dp[k][i][k] + dp[k][k][j])
dp[k][i][j] : k를 사용하지 않는 경우 / dp[k][i][k] + dp[k][k][j] : i->k->j인 경우
실제로 dp는 3차원일 필요는 없고 in-place 갱신이 가능함.
negative cycle의 존재 유무도 판별 가능. dp[v][v] < 0이 되는 꼭짓점 v가존재하면 negative cycle이 존재함.

8. 참고 : potential과 차분 제약계 - wow..
교재 p.320 

9. 정리
그래프의 최단 경로 문제를 구하는 고전적인 해법들을 다룸.
DAG - 동적 계획법
단일 시작점 최단 거리
1. negative edge --> Bellman-Ford(negative cycle도 판단 가능)
2. non-negative edge --> Dijkstra
모든 쌍의 최단 경로 - Floyd-Warshall(negative cycle도 판단 가능)

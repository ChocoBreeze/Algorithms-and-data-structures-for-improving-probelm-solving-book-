// N개ㅑ의 정수가 주어졌을 때, k번째로 작은 정수를 O(N)으로 구하기 --> median of medians
int rec(a, k) {
    // 종단조건
    if (a.size() <= 100) {
         sort(a.begin(), a.end()); 
         return a[k];
    }
  
    // a의 요소를 5개씩 잘라내어 각 그룹의 median을 모은다
    vector<int> a2;
    for (int i = 0; i < a.size(); i += 5) {
        a2.push_back(a[i:i+5] の median);  // ? 구하는 alg 필요
    }
  
    // a2의 median를 구함.
    int m = rec(a2, a.size()/10);
  
    // a를 3개의 그룹으로 나눈다
    vector<int> p, q, r;
    // p - m보다 작은 그룹 / q - m과 같은 그룹 / r - m보다 큰 그룹
    for (int i = 0; i < a.size(); ++i) {
        if (a[i] < m) p.push_back(a[i]);
        else if (a[i] == m) q.push_back(a[i]);
        else r.push_back(a[i]);
    }

    // 재귀적으로 푼다.
    int res;
    if (k <= p.size()) return rec(p, k);
    else if (k <= p.size() + q.size()) return m;
    else return rec(r, k - p.size() - q.size());
}
// 참고
// https://2jinishappy.tistory.com/127
// https://2jinishappy.tistory.com/124
/*
우선 종단 조건에서는 배열의 사이즈가 100 (다른 정수라면 무엇이든 좋다) 이하가 된 시점에서 배열에 대한 정렬 처리를 하고 있습니다.
여기에서 배열 사이즈가 정수 이하임을 보증하고 있기 때문에 이 처리는 정수 시간으로 간주할 수 있습니다.
그런데, 배열 a의 사이즈를 N으로서 이 알고리즘의 계산시간을 T(n)라고 나타내기로 하면 다음과 같은 점화식으로 평가할 수 있습니다.

　　T(n) <= T(n/5) + T(7n/10) + O(n)

먼저 T(n/5)란 배열 a2의 미디어를 구하는 처리를 나타냅니다.
다음 T(3n/4)는 재귀적으로 푸는 부분을 의미합니다.
주의할 점은
p.size() <= 7n/10
r.size() <= 7n/10
이 성립되는 것입니다.
예를 들어 p에 대해 생각했을 때, 배열 a를 5개씩 나눈 그룹 중 미디어언이 m보다 큰 그룹(그 그룹수는 대략 n/10개 있습니다)에 대해서는 그 상위 3개의 요소는 m이상인 것이 확실하기 때문입니다.
즉, 적어도 3n/10개의 요소는 m 이상임이 확정됩니다.이상으로 배열 p의 사이즈는 7n/10 이하로 나타났습니다.배열 r에 대해서도 마찬가지입니다.

그런데 T (n)의 점화식에서 n/5 + 7n/10 = 9n/10으로, 이것은 n보다 작아지고 있습니다.
즉, 분할통치법에 따라 재귀가 진행되었을 때 원래 문제보다 크기가 작은 부분 문제군으로 귀착되었음을 알 수 있습니다.
이러한 때, 12.4.3절의 논의(a < b의 경우)와 마찬가지로 계산량이 O(n)가 되는 것이 나타납니다.

이상과 같이 분할통치법에 기초한 재귀적 알고리즘으로서 분할한 부분문제의 총합이 원래 문제보다 작은 것을 특히 축소법이라고 부르는 경우가 있습니다.
*/

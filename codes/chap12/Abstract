정렬 : 데이터의 열을 특정 순서에 따라 줄 세우는 과정임.
+분할 정복, 힙 같은 자료 구조, 난수 알고리즘 등 다양한 알고리즘 기법을 배울 수 있는 주제임


1.정렬(sort)이란?
데이터 열을 특정 순서에 따라 나열하는 것
직접 정렬하는 것 외에 다양한 문제를 효율적으로 풀기 위한 전처리로도 사용함.

삽입 정렬(O(N^2)), 병합 정렬(O(NlogN)), 퀵 정렬(O(NlogN)), 힙 정렬(O(NlogN)), 버킷 정렬(O(N+A))
삽입 정렬은 O(NlogN)으로 개선 가능

2. 정렬 알고리즘의 좋고 나쁨
1) in-place와 안정성
평가 척도 --> 
복잡도(시간)
추가로 필요한 메모리 용량(in-place성) : 배열 내부의 swap만으로도 수행 가능한지
안정 정렬 여부(안정성) : 정렬 전후로 동일한 값을 가진 요소끼리 순서 관계가 보장되는가?
안정성이 왜 중요한거임? - key가 여러 개인 경우에 중요하다.

C++에서는?
-안정성을 보장하지는 않지만 빠른 std::sort()
-안정성을 보장하는 std::stable_sort()
존재하는 수십 가지의 정렬 알고리즘을 전부 다 아는 것보다 어떤 경우에 정렬이 필요한지 습득하는 것이 더 중요
또한, 정렬 알고리즘은 복잡도 개선, 분할 정복법, 무작위 알고리즘 등 다양한 알고리즘 기법을 배울 수 있는 좋은 주제임

3. 삽입 정렬(insertion sort) (12_1)
왼쪽에서 i개가 정렬된 상태에서 i+1개가 정렬된 상태로 만드는 정렬 알고리즘.
i+1번째 원소에 대해 기존 i개의 정렬된 배열 사이의 적절한 위치에 insert(삽입)
최악의 경우 -> (1+2+....N-1) -> O(N^2)
이미 정렬이 끝난 경우 고속으로 끝남.
삽입 정렬의 장점으로는 in-place 정렬, 안정 정렬임.

4. 병합 정렬(merge sort) (12_2)
O(NlogN)
배열을 반으로 분할하고 좌우 각각을 재귀적으로 정렬해서 양쪽을 병합하는 걸 반복
병합하는 과정에서 왼쪽 배열과 뒤집은 오른쪽 배열을 붙여 양 끝(더 작은 값)을 비교해 가면서 새로운 배열에 복사
분할과 병합이 각각 O(logN)번 필요하고 병합 작업이 O(N)이므로 O(NlogN)이 된다.

외부 메모리가 필요하므로 in-place를 만족하지 않음.
임베디드 시스템처럼 소프트웨어 이식성도 중요하면서 빠른 알고리즘도 필요한 경우 병합 정렬을 꺼리는 경우가 있음.
하지만 배열을 입력받는 시점에 이미 O(N) 메모리가 필요하다는 것을 생각하면 병합 정렬에 필요한 메모리 공간은 입력이 차지하는 메모리의 k배 정도임.
이 정도 추가 공간은 큰 문제가 없는 경우가 많음.

병합 정렬이 안정 정렬이라 좋은 케이스도 많음.
std::sort()는 quick sort로 구현하는 경우가, std::stable_sort는 merge sort로 구현하는 경우가 많음.

5. 퀵 정렬(quick sort) (12_3)
배열을 분할해서 각각 재귀적으로 풀어 합치는 분할 정복법을 따름.
최악의 경우 O(N^2)(pivot을 가장 큰 원소나 가장 작은 원소를 택한 경우)이며, 평균 시간 복잡도는 O(NlogN)임.
적당한 요소 pivot을 고른후 pivot 미만 그룹과 pivot 이상 그룹으로 분할해 각각 재귀적으로 품.
퀵 정렬은 in-place성이 존재함.
최악의 경우 시간 복잡도가 O(N^2)이지만 실제로 사용해보면 병합 정렬보다 빠르게 동작함.
C++ 표준 라이브러리인 std::sort()도 퀵 정렬을 기반으로 하는 경우가 많으며, 최악의 경우 시간 복잡도가 O(NlogN)이라고 표기함.
구체적으로는 std::sort 라이브러리 구현에 달려 있지만, 예를 들어 GNU Standard C++ library라면 힙 정렬과의 하이브리드 방식인 Intro sort을 기반으로 구현함.

3)퀵 정렬의 약점을 개선하는 무작위 선택 퀵 정렬(Randomized quick sort)
알고리즘을 무작위화하면 악의적인 입력 패턴이나 편중된 입력값에 대처하는 데 유효함.
1+1/2+1/3+...+1/ㅜ = O(logN)

6. Heap sort (12_4)
병합 정렬과 마찬가지로 최악의 경우에도 O(NlogN)
안정 정렬도 아니고 평균적인 속도 면에서 퀵 정렬에 비해 떨어지지만, 힙 자체는 중요한 자료 구조임.
1. 주어진 모든 원소를 힙에 삽입(O(logN) * N)
2. 힙의 최대값을 순서대로 pop해서 배열 뒤부터 채우기(O(logN)*N)
힙을 따로 만들지 않고 정렬하고 싶은 배열 자체를 힙으로 만들어 in-place 알고리즘으로 만들 수 있음.

7. 정렬 복잡도의 하한값
비교 정렬 알고리즘 --> 입력된 요소끼리 비교하는 작업에만 기반해서 정렬 순서가 결정됨.
이는 정렬을 위해 적어도 NlogN번의 비교가 필요함
따라서 merge sort, heap sort은 점근적으로 가장 좋은 비교 정렬 알고리즘이라 할 수 있음.

8. bucket sort (12_5)
비교 정렬 알고리즘이 아님.
정렬하고 싶은 배열 a의 각 요소의 값이 0이상 A 미만 정수라는 가정하에서 O(N+A) 복잡도를 달성할 수 있음.
num[x] : 배열 a에 값 x인 요소가 몇 개 존재 하는가?
정렬 대상 배열이 0이상 A 미만인 정수이고 A가 A=O(N) 정도로 무척 한정적인 상황에서만 사용가능함.
한정적인 상황에서는 퀵 정렬보다 훨씬 빠르게 정렬이 가능함.

9. 정리
몇몇 정렬 알고리즘을 소개하면서 분할 정복법, 복잡도 분석, 무작위 선택 알고리즘 사고법 등 다양한 알고리즘 기법을 설명함.
정렬은 다양한 알고리즘의 전처리 작업으로 유용함.
ex) 배열 이진 탐색, greedy method(최초로 어떤 척도에 따라 대상을 오름차순으로 정렬하는 편임), 컴퓨터 그래픽 분야(Z buffer alg)에서도 사용

DP(Dynamic Programming)
의외로 몇 가지 정형적인 패턴이 존재함.

재귀 함수를 사용한 방법 이외에도 다양한 동적 계획법 실현 방법이 존재함.

주어진 문제 전체를 일련의 부분 문제로 잘 분해해 각 부분 문제의 답을 memoization하면서 작은 부분 문제에서 큰 부분 문제로 순서대로 답을 구하는 방법.
무수히 많은 상태를 얼마나 잘 정리해 부분 문제로 구성하는지가 관건임.

동적 계획법을 사용해서 효율적으로 풀 수 있는 문제들
Knapsack
Scheduling
발전 계획 문제( 뭔지 잘 모르 겠음)
edit distance
음성 인식 패턴 매칭 문제
문장 띄어쓰기
hidden Markov model(HMM)

해결 가능한 문제의 폭이 넓은 대신, 방법을 적용하는 패턴이 다양해서 습득하기 어려우나,
동적 계획법이 일련의 부분 문제로 분해하는 방법이란 점에 주목하면 알려진 패턴은 그렇게 많지 않음.
연습을 충실히 거듭한다면 몇몇 패턴을 의식하기만 해도 많은 문제를 해결가능할 것.

예제.
개구리 1 (5_1)
https://atcoder.jp/contests/dp/tasks/dp_a
i번째 답을 i-1번째 답 or i-2번째 답을 이용함. (부분 문제로 분할) (그냥 피보나치네 ㅋㅋ)
원래 문제가 최적의 답인 경우에 작은 부분 문제도 마찬가지로 최적이 되어야 함 --> 최적 하위 구조 or 최적 부분 구조(optimal substructure)라 함.
이런 구조를 이용해서 각 부분 문제에 대한 최적값을 순서대로 결정하는 방법이 동적 계획법.
최적 부분 구조란 합칠 수 있는 처리를 합쳐서 중복 계산을 피해 속도를 높이는 동적 계획법 사고방식을 표현한 것이라 할 수 있음.

동적 계획법 관련 개념도
1. 완화(relaxation) (14장에서 상세히 다룸) (5_2, 5_3, 5_4)
-쉽게 말해 배열 dp에서 각 값이 점점 작아지는 값으로 갱신되어 가는 분위기만 파악!
-그래프에서 사용 가능( 값 갱신)

- 끌기 전이 형식과 밀기 전이 형식
끌기 전이 형식(pull-based) : i보다 더 작은 값에서 i로 가기
밀기 전이 형식(push-based) : i에서 i보다 큰 값으로 가기
완화할 변 순서만 다를 뿐, 두 형식에 대해 중요한 내용은 u -> v로 가는 전이에서 u에 해당하는 값이 확정되어야 한다는 점임.

개구리를 푸는 또 다른 방법
동적 계획법은 가끔 단순한 전체 탐색 알고리즘을 설계할 때 지수 시간 복잡도인 문제에 대해서도 다항식 시간 복잡도인 알고리즘을 유도할 수 있는 강력한 도구임.
--> 경로를 모두 탐색하는 방법 + Memoization 갱신 (5_6)
Memoization 재귀는 동적 계획법을 재귀 함수를 사용해서 실현한 것이라고 봐도 무방함.


예제(1) Knapsack 문제 (5_7)
-동적 계획법만 존재하는 것이 아니라 다양한 선택지가 존재함.
동적 계획법 부분 문제를 만드는 기본 패턴:
N개의 대상물과 관련된 문제에 있어, 최초 i개의 대상물과 관련된 문제는 N개를 대상으로 한 문제의 부분 문제라고 볼 수 있음.
dp[i] -> dp[i+1] : i의 선택 여부는 확인 가능 해도, 무계 합계가 한계를 넘어가는지는 확인할 수 없음.
dp[i][w] - 최초 i개의 물건 중에서 무게가 w를 넘지 않도록 고른 가격 총합의 최대값.
일단 만들어 본 테이블 설계로 전이가 되지 않을 것 같으면 점점 인덱스를 추가(차원 늘리기)해서 전이가 성립하도록 하는 작업을 반복하기.
인덱스 추가는 선택지가 점점 꼼꼼해지는 정도에 비례함.

예제(2) Edit Distance(편집 거리) : 두 문자열 S, T가 얼마나 닮았는지 그 유사성을 측정하는 방법. (5_8)
-계열과 인덱스가 여러 개인 동적 계획법
두 계열의 유사성을 계측하는 문제는 다양하게 응용 가능하므로 무척 중요함.
문자열 S를 T로 변환하려고 함, 작업 횟수가 최소가 되는 값을 구하기.(편집거리 구하기)
작업 : 대체, 삭제, 삽입
dp[i][j] - S의 i번째까지의 문자열과 T의 j번째까지의 문자열 사이의 편집 거리
길이가 서로 다른 서열의 유사도를 어떻게 구하는가 라는 질문에 대한 지침 중 하나임.
길이가 서로 다른 두 계열 사이에서 유사도를 구할 때 
	대응시키기(몇 번째와 몇 번째를 대응시킬지 최적화하기) --> edit distance
	매칭시키기(각 요소끼리 순서를 유지하면서 매칭하는 방법을 최적화하기) --> minimum cost elastic matching(최소 비용 탄성 매칭 문제) --> 좀 더 찾아보기

예제(3)
일렬로 나열한 N개의 대상물을 구간으로 나눠서 분할하는 방법을 최적화하는 문제
N개의 요소를 일렬로 나열하고 몇 개의 구간으로 분할하려 함. 각 구간 [l, r)에는 구간에 해당하는 스코어가 존재할 때
가능한 N 요소의 구간 분할 방법 중에서 스코어가 최소가 되는 값을 구하라.
dp[i] - 구간 [0, i)에 대해 구간을 분할하는 최소 비용

동적 계획법의 복잡도는 배열 dp의 크기 뿐만 아니라 완화 처리 대상이 되는 전이 개수에도 의존하므로 주의하기.

동적 계획법의 table 설계 패턴에 주목하기
다양한 문제 풀자.

이진 탐색법
탐색 범위를 반으로 줄여가면서 답을 찾는 방법
배열 탐색 수단으로만 보지 않고 좀 더 광범위하게 응용 가능한 알고리즘 설계 방법으로 설명함.

1. 배열 이진 탐색 (6_1)

2. C++의 std::lower_bound()
정렬된 배열 a에서 a[i]>=key인 조건을 만족하는 최소 인덱스 i를 돌려줌(iterator 값),
처리에 필요한 복잡도의 크기는 배열의 크기가 N일 때, O(logN)임.
+ 배열 a에 key 값이 존재하지 않아도 key 값 이상의 범위에서 최솟값을 알 수 있음.
+ 여러 개의 key 값이 존재하는 경우 처음 나오는 인덱스를 알 수 있음.

+ upper_bound()
<algorithm>에 있음.

3. 일반화한 이진 탐색법 (6_2)
조건 P에 대해서 left(l)과 right(r)이 있을 때, P(l)=false, P(r)=true이고,
l<=M <r 인 M에 대해서 x < M인 x는 P(x) = false이고, x>=M인 x에 대해 P(x) = true이다.
D = r-1이라면, 이진 탐색법은 M을 O(logD) 복잡도로 구할 수 있는 알고리즘이라 한다.
(right-left = 1일 때까지 범위 줄여 나가기)

정수인 경우를 넘어서 실수에도 적용 가능함, 이 경우를 이분법이라고 부르기도 함.

4.좀 더 일반화한 이진 탐색법(*)
false와 true 영역이 둘로 나눠지는 것(단조성)이 아니라 여러 개 존재하는 경우도 생각해 볼 수 있음.
여러 개의 경계 중 하나를 이진 탐색법으로 구함.
실수의 이진 탐색법 -- 중간값 정리(intermediate value theorem)

5. 예시 1. 나이 맞히기 게임 (6_3)

6. 예시 2. std::lower_bound() 활용 (6_4)
-더한 값이 K 이상인 범위에서 최소 값 찾기
값 하나를 정한 후 다른 값을 lower_bound로 찾기 --> 미리 정렬 필요!.

7. 예시 3. 최적화 문제를 판정 문제로 바꾸기 (6_5)
-어떤 경계값 v가 존재하며, v 이상은 조건을 만족하고 v 미만은 조건을 만족하지 않는 상태.
--> 판정 문제로 바꾸기(x가 조건을 만족하는지 여부를 판정하기)
문제가 오래 돼서 링크를 못 찾음.

N개의 최대값 중에서 가장 작은 값을 구하고 싶다는 형식의 최적화 문제.

8. 중앙값 구하기
정렬 - O(NlogN)

N개의 음수가 아닌 정수 a0, a1, ... aN-1 중에서 x 미만인 정수가 N-1/2개 이상 존재하는지 여부 판정하기.
답이 yes인 가장 작은 정수 x가 중앙값. --> logA
선형 탐색법을 사용해 N개의 정수를 대상으로 --> N
따라서 O(NlogA)


최적화 문제를 판정 문제로 바꿔 생각해 보는 방법.
+특정 값이 존재하는지 확인하기 위한 방법으로 해시 테이블도 좋음.
